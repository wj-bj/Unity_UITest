明白了。您的需求是：
同一时间可以有一个背景转场效果和一个前景转场效果同时存在
在窗口打开或关闭时，触发事件来控制是否开启或关闭这些效果
每个UI窗口可以独立配置自己的背景和前景转场效果
这样设计的好处是灵活性高，可以为不同的UI窗口配置不同的视觉效果组合，提升用户体验。例如：
主菜单可能使用模糊背景和淡入前景
对话框可能使用暗色背景和缩放前景
游戏内HUD可能不使用任何转场效果
这些效果会在窗口的生命周期事件（打开、关闭）中被触发，并且可以通过UIManager来统一管理。


目前blur渲染的做法是由于canvas 采用的是screen-overlay的方式，所以原来的camera.Render方法没法截取带图片的截图，所以采用延后一帧screenshot的方法。这就要求作为基底的界面不能关闭或延后关闭。考虑到作为stack的界面会互相遮盖，也用不到blur背景效果。目前的界面布局是 基底界面->背景UI(BlurEffect)->浮动UI->前景UI(转场,Loading界面)



        private RenderTexture srcRT = null;

        private void BeginFrameRendering(ScriptableRenderContext context, Camera[] cameras)
        {
         
            foreach (var cam in cameras)
            {
                if (cam.cameraType == CameraType.SceneView)
                    return;
            }
            foreach (var cam in cameras)
            {
               
                    CameraCaptureBridge.AddCaptureAction(cam,CameraCaptureAction);
            }
            
            if (srcRT == null)
            {
                var width = Screen.width;
                var height = Screen.height;
                srcRT = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.Default);
                srcRT.name = "srcRT";
            }
        }
        
        private void EndFrameRendering(ScriptableRenderContext context, Camera[] cameras)
        {
            foreach (var cam in cameras)
            {
                if (cam.cameraType == CameraType.SceneView)
                    return;
            }
            foreach (var cam in cameras)
            {
                CameraCaptureBridge.RemoveCaptureAction(cam,CameraCaptureAction);
            }

            if (srcRT != null)
            {
                RenderTexture currentActiveRT = RenderTexture.active;
                ProcessBlurEffect(srcRT);
               
                RenderTexture.ReleaseTemporary(srcRT);
                srcRT = null;
                RenderTexture.active = currentActiveRT;
            }

            enabled = false;
        }

        

        private void CameraCaptureAction(RenderTargetIdentifier source, CommandBuffer cmd)
        {
           
            cmd.Blit(source,srcRT);
            
        }